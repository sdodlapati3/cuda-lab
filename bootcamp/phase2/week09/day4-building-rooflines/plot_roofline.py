#!/usr/bin/env python3
"""
plot_roofline.py - Create a roofline model visualization

Reads roofline_data.csv generated by roofline_data.cu
"""

import matplotlib.pyplot as plt
import numpy as np
import csv
import os

def plot_roofline(peak_bw_gbps=1500, peak_gflops=15000):
    """Create roofline plot with ceilings and kernel points."""
    
    # Read data if available
    kernels = []
    if os.path.exists('roofline_data.csv'):
        with open('roofline_data.csv', 'r') as f:
            reader = csv.DictReader(f)
            for row in reader:
                if row['kernel'] == 'peak_bw':
                    peak_gflops = float(row['gflops'])
                    ridge_ai = float(row['ai'])
                    peak_bw_gbps = peak_gflops / ridge_ai
                else:
                    kernels.append({
                        'name': row['kernel'],
                        'ai': float(row['ai']),
                        'gflops': float(row['gflops'])
                    })
    
    # Calculate ridge point
    ridge_ai = peak_gflops / peak_bw_gbps
    
    # Create figure
    fig, ax = plt.subplots(figsize=(12, 8))
    
    # AI range for plotting (log scale)
    ai_range = np.logspace(-2, 3, 500)  # 0.01 to 1000 FLOPS/byte
    
    # Memory ceiling: performance = AI * BW
    mem_ceiling = ai_range * peak_bw_gbps
    
    # Compute ceiling: flat line
    compute_ceiling = np.full_like(ai_range, peak_gflops)
    
    # The roofline: minimum of both
    roofline = np.minimum(mem_ceiling, compute_ceiling)
    
    # Plot ceilings
    ax.loglog(ai_range, mem_ceiling, 'b--', linewidth=1.5, alpha=0.7, 
              label=f'Memory ceiling ({peak_bw_gbps:.0f} GB/s)')
    ax.loglog(ai_range, compute_ceiling, 'r--', linewidth=1.5, alpha=0.7,
              label=f'Compute ceiling ({peak_gflops:.0f} GFLOPS)')
    ax.loglog(ai_range, roofline, 'k-', linewidth=3, 
              label='Roofline')
    
    # Mark ridge point
    ax.axvline(x=ridge_ai, color='gray', linestyle=':', alpha=0.5)
    ax.annotate(f'Ridge Point\nAI = {ridge_ai:.1f}', 
                xy=(ridge_ai, peak_gflops), 
                xytext=(ridge_ai * 2, peak_gflops * 1.5),
                fontsize=10,
                arrowprops=dict(arrowstyle='->', color='gray'))
    
    # Plot kernel points
    colors = plt.cm.tab10(np.linspace(0, 1, len(kernels)))
    for i, k in enumerate(kernels):
        if k['ai'] > 0:
            ax.scatter(k['ai'], k['gflops'], s=150, c=[colors[i]], 
                      edgecolors='black', linewidth=2, zorder=5)
            ax.annotate(k['name'], 
                       xy=(k['ai'], k['gflops']),
                       xytext=(5, 5), textcoords='offset points',
                       fontsize=9)
    
    # Shade regions
    ax.fill_between(ai_range[ai_range <= ridge_ai], 0, 
                    roofline[ai_range <= ridge_ai],
                    alpha=0.1, color='blue', label='Memory-bound region')
    ax.fill_between(ai_range[ai_range > ridge_ai], 0,
                    roofline[ai_range > ridge_ai],
                    alpha=0.1, color='red', label='Compute-bound region')
    
    # Labels and formatting
    ax.set_xlabel('Arithmetic Intensity (FLOPS/byte)', fontsize=12)
    ax.set_ylabel('Performance (GFLOPS)', fontsize=12)
    ax.set_title('Roofline Model - GPU Performance Bounds', fontsize=14)
    ax.legend(loc='lower right', fontsize=10)
    ax.grid(True, alpha=0.3, which='both')
    
    # Set axis limits
    ax.set_xlim(0.01, 1000)
    ax.set_ylim(1, peak_gflops * 3)
    
    # Save and show
    plt.tight_layout()
    plt.savefig('roofline_plot.png', dpi=150, bbox_inches='tight')
    print("Saved: roofline_plot.png")
    plt.show()

if __name__ == '__main__':
    # Default values for A100 if no data file
    plot_roofline(peak_bw_gbps=1555, peak_gflops=19500)
